package myUtil;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;


/**
 * A class monitoring the relations between all components to prevent major logical errors such as 
 * asynchronous circuits which infinitely go into a feedback loop.
 * 
 * @author dimits
 */
public class ComponentGraph {
  private Map<String, Node> nodes = new HashMap<String, Node>();
	
	/**
	 * Used by the DFS algorithm, do *not* manually change its value.
	 */
	private int clock;
	
	/**
	 * Notify the graph that a component has been added to the UI.
	 * @param name the name of the new component
	 */
	public void componentAdded(String name) {
		nodes.put(name, new Node());
	}
	
	/**
	 * Notify the graph that a component has been deleted from the UI.
	 * 
	 * @param name the name of the now-deleted component
	 * @throws IllegalArgumentException if the component's name isn't registered in the graph
	 */
	public void componentDeleted(String name) throws IllegalArgumentException {
		if(nodes.remove(name) == null)
			throw new IllegalArgumentException("There isn't any component named " + name + " in the graph!");
	}
	
	/**
	 * Notify the graph that a branch connecting 2 nodes was deleted.
	 * 
	 * @param connector the <b>branch's</br> input component
	 * @param target the <b>branch's</br> output component
	 * @throws IllegalArgumentException if either of the components' names aren't registered in the graph.
	 */
	public void connectionRemoved(String connector, String target) throws IllegalArgumentException {
		Node conNode = nodes.get(connector);
		Node targetNode = nodes.get(target);
		
		if(conNode == null)
			throw new IllegalArgumentException("There isn't any component named " + conNode + " in the graph!");
		if(targetNode == null)
			throw new IllegalArgumentException("There isn't any component named " + targetNode + " in the graph!");
		conNode.neighbours.remove(targetNode);
	}
	
	/**
	 * Check whether or not a branch connecting 2 components can be safely added.
	 * Make sure to perform the check <i>before</i> the actual branch is added.
	 * The connection will be added to the graph if it's deemed safe to do so.
	 * 
	 * @param connector the <b>branch's</br> input component
	 * @param target the <b>branch's</br> output component
	 * @return true if the operation is safe, false if the operation will lead to an endless loop
	 * @throws IllegalArgumentException if either of the components' names aren't registered in the graph.
	 */
	public boolean componentCanBeConnected(String connector, String target) throws IllegalArgumentException {
		Node first = nodes.get(connector);
		Node last = nodes.get(target);
		if(first == null)
			throw new IllegalArgumentException("There isn't any component named " + first + " in the graph!");
		if(last == null)
			throw new IllegalArgumentException("There isn't any component named " + last + " in the graph!");
		
		first.neighbours.add(last);
		
		//DFS on graph 
		clock = 1;
		for(String key_n : nodes.keySet()) 
			nodes.get(key_n).visited = false;

		for(String key_n : nodes.keySet()) {
			Node n = nodes.get(key_n);
			if(!n.visited)
				explore(n);
		}
		
		/*
		 * For any edge (u,v): if post(u) < post(v) then the graph is not a DAG
		 * so there is a feedback look somewhere in the circuit. 
		 */
		for(String outer_key : nodes.keySet()) {
			Node u = nodes.get(outer_key);
			for(Node v : nodes.get(outer_key).neighbours) {
				
				if(u.post < v.post) {
					u.neighbours.remove(v); //remove faulty connection
					return false;
				}
			}
		}	
		return true;
	}
	
	
	private void explore(Node n) {
		n.previous = clock;
		clock++;
		n.visited = true;
		
		for(Node v : n.neighbours) 
			if(!v.visited) 
				explore(v);
			
		n.post = clock;
		clock++;
	}
	
	
	private class Node {
		List<Node> neighbours = new LinkedList<Node>();
		
		//used by the DFS algorithm above
		int previous;
		int post;
		boolean visited;
	
	}

}

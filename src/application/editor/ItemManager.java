package application.editor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;

import component.components.Identifiable;
import myUtil.StringGenerator;
import myUtil.Utility;

/**
 * Map wrapper for String-T pairs for objects of type T that can be identified
 * by a String ID. Additionally supports automatic ID generation.
 *
 * @param <T> the type of the values stored
 *
 * @author Alex Mandelias
 *
 * @see Identifiable
 * @see StringGenerator
 */
final class ItemManager<T extends Identifiable<String>> {

	private final Map<String, T> itemMap;

	/** A key-Generator map that creates IDs for new items in this manager */
	final Map<String, StringGenerator> idGenerators;

	/** Constructs the ItemManager */
	public ItemManager() {
		// linked to retain the order of the items inserted
		itemMap = new LinkedHashMap<>();
		idGenerators = new HashMap<>();
	}

	/**
	 * Adds an {@code Item} to this Manager.
	 *
	 * @param item the Item to add
	 *
	 * @throws NullPointerException if {@code item == null}
	 * @throws DuplicateIdException if an Item with the same ID already exists in
	 *                              this Manager
	 */
	public void add(T item) {
		final String id = item.getID();
		if (itemMap.containsKey(id))
			throw new DuplicateIdException(id);

		itemMap.put(id, item);
	}

	/**
	 * Removes an {@code Item} from this Manager.
	 *
	 * @param item the Item to remove
	 *
	 * @throws NullPointerException if {@code item == null}
	 */
	public void remove(T item) {
		itemMap.remove(item.getID());
	}

	/**
	 * Returns the unique {@code Item} with the given ID.
	 *
	 * @param id the ID of the Item
	 *
	 * @return the Item with that ID
	 *
	 * @throws MissingComponentException if no Item with the ID exists
	 */
	public T get(String id) throws MissingComponentException {
		final T item = itemMap.get(id);
		if (item == null)
			throw new MissingComponentException(id);

		return item;
	}

	/**
	 * Returns the number of {@code Items} in this Manager.
	 *
	 * @return the number of Items
	 */
	public int size() {
		return itemMap.size();
	}

	/**
	 * Returns every {@code Item} in this Manager.
	 * <p>
	 * <b>Note</b> that this does <i>not</i> return a copy of the items. Any changes
	 * to the Items will be reflected in this ItemManager object.
	 *
	 * @return a List with the Items
	 */
	public List<T> getall() {
		return getall(item -> true);
	}

	/**
	 * Returns the Items for which a {@code predicate} evaluates to {@code true}.
	 * <p>
	 * <b>Note</b> that this does <i>not</i> return a copy of the items. Any changes
	 * to the Items will be reflected in this ItemManager object.
	 *
	 * @param predicate the Predicate that will be evaluated on each Item
	 *
	 * @return a List with the Items
	 */
	public List<T> getall(Predicate<T> predicate) {
		final List<T> list = new ArrayList<>(size());
		Utility.foreach(itemMap.values(), item -> {
			if (predicate.test(item))
				list.add(item);
		});
		return list;
	}

	/**
	 * Returns the next ID generated by the specified Generator.
	 *
	 * @param generatorID the target Generator
	 *
	 * @return the next ID of that Generator
	 *
	 * @throws NullPointerException if the generatorID doesn't correspond to an
	 *                              existing Generator
	 */
	public String getNextID(String generatorID) {
		return idGenerators.get(generatorID).get();
	}

	/**
	 * Creates a Generator. If a Generator with the same ID already exists, it will
	 * be replaced with a new one.
	 *
	 * @param generatorID the Generator's ID
	 * @param text        the text that will be formatted
	 */
	public void addGenerator(String generatorID, String text) {
		addGenerator(generatorID, new StringGenerator(text));
	}

	/**
	 * Creates a Generator. If a Generator with the same ID already exists, it will
	 * be replaced with a new one.
	 *
	 * @param generatorID the Generator's ID
	 * @param text        the text that will be formatted
	 * @param start       the initial counter value
	 */
	public void addGenerator(String generatorID, String text, int start) {
		addGenerator(generatorID, new StringGenerator(text, start));
	}

	/**
	 * Creates a Generator. If a Generator with the same ID already exists, it will
	 * be replaced with the new one.
	 *
	 * @param generatorID the Generator's ID
	 * @param text        the text that will be formatted
	 * @param start       the initial counter value
	 * @param end         the final counter value
	 */
	public void addGenerator(String generatorID, String text, int start, int end) {
		addGenerator(generatorID, new StringGenerator(text, start, end));
	}

	private void addGenerator(String generatorID, StringGenerator generator) {
		idGenerators.put(generatorID, generator);
	}

	/**
	 * Removes a Generator.
	 *
	 * @param generatorID the Generator's ID
	 *
	 * @return {@code true} if a Generator with that ID was removed successfully
	 *         {@code false} if no such generator exists
	 */
	public boolean removeGenerator(String generatorID) {
		return idGenerators.remove(generatorID) != null;
	}

	/**
	 * Returns the Generators in this Manager.
	 * <p>
	 * <b>Note</b> that this does <i>not</i> return a copy of the Generators. Any
	 * changes to them will be reflected in this Manager.
	 *
	 * @return a Map containing the Generators and their IDs
	 */
	public Map<String, StringGenerator> getGenerators() {
		return new HashMap<>(idGenerators);
	}

	@Override
	public String toString() {
		return String.format("{%s, %s}", itemMap, idGenerators); //$NON-NLS-1$
	}

	/**
	 * Thrown when another Item is already associated with an {@code ID}.
	 *
	 * @author Alex Mandelias
	 */
	public static class DuplicateIdException extends RuntimeException {

		/**
		 * Constructs the Exception with an {@code ID}.
		 *
		 * @param id the duplicate ID for which an Item already exists
		 */
		public DuplicateIdException(String id) {
			super(String.format("Another Item associated with ID '%s'", id)); //$NON-NLS-1$
		}
	}
}
